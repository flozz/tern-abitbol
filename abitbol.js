"use strict";

var path = require("path");

var tern = require("tern/lib/tern");
var infer = require("tern/lib/infer");


// helpers

var _classUniqId = 0;

function _getUniqClassId() {
    _classUniqId += 1;
    return "AbitbolClass" + _classUniqId;
}

function _getClassName(extendArgNode) {

    function _getVariableName(text, argStart) {
        var varRegexp = /^.*(var\s+|let\s+|const\s+|\s|\.)([A-Z][A-Za-z0-9_]*)\s*(=|:)\s*([A-Z][A-Za-z0-9_]*)\.\$extend\($/;
        var buff = text.substr(0, argStart).replace(/\r?\n/g, " ");
        if (buff.match(varRegexp)) {
            return buff.replace(varRegexp, "$2");
        }
    }

    if (!extendArgNode) {
        return _getUniqClassId();
    }

    var className = _getVariableName(extendArgNode.sourceFile.text, extendArgNode.start);

    if (!className) {
        className = _getUniqClassId();
    }

    return "(" + path.basename(extendArgNode.sourceFile.name) + ")." + className;
}

function _isPrivate(name) {
    return name.indexOf("_") === 0;
}

function _isGetter(name) {
    return name.indexOf("get") === 0 || name.indexOf("is") === 0 || name.indexOf("has") === 0;
}

function _isAbitbolSpecialProperty(name) {
    var specialProp = [
        "$extend", "$map", "$class",
        "$data", "$super",
        "$name", "$computedPropertyName",
        "__include__", "__classvars__", "__init__"
    ];
    return specialProp.indexOf(name) >= 0;
}

function _isJsPropertyToSkip(name) {
    var jsProp = [
        "constructor", "prototype"
    ];
    return jsProp.indexOf(name) >= 0;
}

function _getterToPropertyName(name) {
    var accessorNameLength = 3;
    if (name.indexOf("is") === 0) {
        accessorNameLength = 2;
    }
    var propName = name.slice(accessorNameLength, accessorNameLength + 1).toLowerCase();
    propName += name.slice(accessorNameLength + 1, name.length);
    return  propName;
}

function _propagateProperties(source, destination, getset) {
    var hidePrivate = false;  // TODO make this configurable

    var mapAttributes = [];
    var mapMethods = [];
    var mapComputedProperties = [];

    source.forAllProps(function(prop, val, local) {
        if (!local) return;
        if (_isJsPropertyToSkip(prop)) return;
        if (_isAbitbolSpecialProperty(prop)) return;
        if (_isPrivate(prop) && hidePrivate) return;

        val.propagate(destination.defProp(prop));

        if (val.getType() && val.getType().toString().indexOf("fn(") === 0) {
            mapMethods.push(prop);
        } else {
            mapAttributes.push(prop);
        }

        // autogenerated conmputed property
        if (!getset) return;
        if (_isGetter(prop)) {
            var propertyType = val.getType();
            var computedProperty = destination.defProp(_getterToPropertyName(prop));
            if (propertyType && propertyType.retval) {
                propertyType.retval.propagate(computedProperty);
            }
            mapComputedProperties.push(_getterToPropertyName(prop));
            // TODO propagate getter's doc
        }
    });

    return {
        attributes: mapAttributes,
        methods: mapMethods,
        computedProperties: mapComputedProperties
    };
}

function _fillMapObject(map, data) {
    var mapType = map.getType();
    var mapAttributesType = mapType.getProp("attributes").getType();
    var mapMethodsType = mapType.getProp("methods").getType();
    var mapComputedPropertiesType = mapType.getProp("computedProperties").getType();

    var i;
    var prop;
    var propType;

    for (i = 0 ; i < data.attributes.length ; i++) {
        prop = mapAttributesType.defProp(data.attributes[i]);
    }

    for (i = 0 ; i < data.methods.length ; i++) {
        prop = mapMethodsType.defProp(data.methods[i]);
        propType = new infer.Obj(true, data.methods[i]);
        prop.addType(propType);

        propType.defProp("annotations");
    }

    for (i = 0 ; i < data.computedProperties.length ; i++) {
        prop = mapComputedPropertiesType.defProp(data.computedProperties[i]);
        propType = new infer.Obj(true, data.computedProperties[i]);
        prop.addType(propType);

        propType.defProp("get");
        propType.defProp("set");
        propType.defProp("annotations");
    }
}


// basic class definition

var defs = {

    "!name": "abitbol",

    "!define": {
        "!known_modules": {
            "abitbol": {
                "!type": "Class"
            }
        },

    },

    "Class": {
        "!type": "fn(?) -> +Class",
        "$extend": {
            "!type": "fn(properties: ?) -> !custom:abitbolExtend",
            "!effects": ["custom abitbol_extend"]
        },
        "$class": {
            "!type": "Class"
        },
        "$map": {
            attributes: {
                "!type": "Obj"
            },
            methods: {
                "!type": "Obj"
            },
            computedProperties: {
                "!type": "Obj"
            }
        },
        "prototype": {
            "$class": {
                "!type": "Class"
            },
            "$map": {
                attributes: {
                    "!type": "Obj"
                },
                methods: {
                    "!type": "Obj"
                },
                computedProperties: {
                    "!type": "Obj"
                }
            },
            "$data": {
                "!type": "Obj"
            },
            "$super": {
                "!type": "fn()"
            }
        }
    }

};


// plugin functions

infer.registerFunction("abitbolExtend", function(_self, args, argNodes) {
    var newProperties = args[0];
    var mapData;

    // Class / constructor
    var constructor = newProperties.hasProp("__init__");
    if (!constructor) constructor = _self.getProp("prototype").getType().hasProp("__init__");
    var constructorArgs = [];
    var constructorArgNames = [];

    if (constructor) {
        constructorArgs = constructor.getType().args;
        constructorArgNames = constructor.getType().argNames;
    }

    var abitbolClass = new infer.Fn(_getClassName(argNodes[0]), new infer.AVal(), constructorArgs, constructorArgNames, new infer.AVal());
    var abitbolClassPrototype = abitbolClass.getProp("prototype").getType();

    if (constructor) {
        constructor.propagate(abitbolClassPrototype.defProp("__init__"));
    }

    // abitbol static $map
    var mapStaticProp = abitbolClass.defProp("$map");
    mapStaticProp.addType(new infer.Obj(true, "$map"));

    var mapStaticPropAttributes = mapStaticProp.getType().defProp("attributes");
    mapStaticPropAttributes.addType(new infer.Obj(true, "attributes"));

    var mapStaticPropMethods = mapStaticProp.getType().defProp("methods");
    mapStaticPropMethods.addType(new infer.Obj(true, "methods"));

    var mapStaticPropComputedProperties = mapStaticProp.getType().defProp("computedProperties");
    mapStaticPropComputedProperties.addType(new infer.Obj(true, "computedProperties"));

    if (constructor) {
        _fillMapObject(mapStaticProp, {attributes: [], methods: ["__init__"], computedProperties: []});
    }

    // abitbol instance $map
    var mapProp = abitbolClassPrototype.defProp("$map");
    mapProp.addType(new infer.Obj(true, "$map"));

    var mapPropAttributes = mapProp.getType().defProp("attributes");
    mapPropAttributes.addType(new infer.Obj(true, "attributes"));

    var mapPropMethods = mapProp.getType().defProp("methods");
    mapPropMethods.addType(new infer.Obj(true, "methods"));

    var mapPropComputedProperties = mapProp.getType().defProp("computedProperties");
    mapPropComputedProperties.addType(new infer.Obj(true, "computedProperties"));

    if (constructor) {
        _fillMapObject(mapProp, {attributes: [], methods: ["__init__"], computedProperties: []});
    }

    // parent class static properties
    _propagateProperties(_self, abitbolClass, false);

    // parent class properties
    var parentClassProperties = _self.getProp("prototype").getType();
    mapData = _propagateProperties(parentClassProperties, abitbolClassPrototype, true);
    _fillMapObject(mapStaticProp, mapData);
    _fillMapObject(mapProp, mapData);

    // new class static properties (__classvars__)
    var classvarsProperties = newProperties.hasProp("__classvars__");
    if (classvarsProperties) {
        _propagateProperties(classvarsProperties, abitbolClass, false);
    }

    // new class mixin properties (__include__)
    var mixinArray = newProperties.hasProp("__include__");
    if (mixinArray) {
        var mixinProperties = mixinArray.getProp("<i>");
        mapData = _propagateProperties(mixinProperties, abitbolClassPrototype, true);
        _fillMapObject(mapStaticProp, mapData);
        _fillMapObject(mapProp, mapData);
    }

    // new class properties / computed properties
    mapData = _propagateProperties(newProperties, abitbolClassPrototype, true);
    _fillMapObject(mapStaticProp, mapData);
    _fillMapObject(mapProp, mapData);

    // abitbol special properties
    // $extend
    var extendProp = _self.getProp("$extend");
    extendProp.propagate(abitbolClass.defProp("$extend"));

    // abitbol $class
    abitbolClass.propagate(abitbolClass.defProp("$class"));
    abitbolClass.propagate(abitbolClassPrototype.defProp("$class"));

    // abitbol $data
    var dataProp = abitbolClassPrototype.defProp("$data");
    dataProp.addType(new infer.Obj(true, "$data"));

    // abitbol $super
    var superProp = abitbolClassPrototype.defProp("$super");
    superProp.addType(new infer.Fn("$super", new infer.AVal(), [], [], new infer.AVal()));

    return abitbolClass;
});

tern.registerPlugin("abitbol", function(server, options) {
    server.addDefs(defs);
});

